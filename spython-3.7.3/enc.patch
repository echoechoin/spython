diff --git a/Include/decrypt_source_file.h b/Include/decrypt_source_file.h
new file mode 100644
index 0000000..2743b6c
--- /dev/null
+++ b/Include/decrypt_source_file.h
@@ -0,0 +1,31 @@
+#ifndef _DECRYPY_SOURCE_FILE
+#define _DECRIPT_SOURCE_FILE
+#include <Python.h>
+#include <math.h>
+
+#include <openssl/aes.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+/**
+ * @description: decrypt_file.c使用对称加密算法AES加密文件，密钥长度为128bit 
+ * @dependencies: openssl
+ */
+
+#define KEY  "8cc72b05705d5c46f412af8cbed55aad"
+#define IV   "667b02a85c61c786def4521b060265e8"
+#define HEADINFO "encrypted-python-source-file-header"
+#define _NO_DECRYPT_FILE_OUTPUT // 是否需要输出解密后的文件
+
+// 可以使用的函数
+int test(void);
+FILE * d_open();
+int dopen(const char *pathname, int flags, mode_t mode);
+
+#endif
\ No newline at end of file
diff --git a/Makefile.pre.in b/Makefile.pre.in
index 2d2e11f..01de091 100644
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -230,7 +230,7 @@ INSTSONAME=	@INSTSONAME@
 LIBS=		@LIBS@
 LIBM=		@LIBM@
 LIBC=		@LIBC@
-SYSLIBS=	$(LIBM) $(LIBC)
+SYSLIBS=	$(LIBM) $(LIBC) -lssl -lcrypto
 SHLIBS=		@SHLIBS@
 
 DLINCLDIR=	@DLINCLDIR@
@@ -329,6 +329,7 @@ PGENOBJS=	$(POBJS) $(PGOBJS)
 # Python
 
 PYTHON_OBJS=	\
+		Python/decrypt_source_file.o \
 		Python/_warnings.o \
 		Python/Python-ast.o \
 		Python/asdl.o \
diff --git a/Modules/_io/fileio.c b/Modules/_io/fileio.c
index 8bbe1ce..e758014 100644
--- a/Modules/_io/fileio.c
+++ b/Modules/_io/fileio.c
@@ -17,6 +17,7 @@
 #endif
 #include <stddef.h> /* For offsetof */
 #include "_iomodule.h"
+#include "decrypt_source_file.h"
 
 /*
  * Known likely problems:
@@ -376,7 +377,7 @@ _io_FileIO___init___impl(fileio *self, PyObject *nameobj, const char *mode,
 #ifdef MS_WINDOWS
                 self->fd = _wopen(widename, flags, 0666);
 #else
-                self->fd = open(name, flags, 0666);
+                self->fd = dopen(name, flags, 0666);
 #endif
                 Py_END_ALLOW_THREADS
             } while (self->fd < 0 && errno == EINTR &&
diff --git a/Modules/main.c b/Modules/main.c
index a745381..50e6043 100644
--- a/Modules/main.c
+++ b/Modules/main.c
@@ -85,7 +85,6 @@ static const char usage_1[] = "\
 Options and arguments (and corresponding environment variables):\n\
 -b     : issue warnings about str(bytes_instance), str(bytearray_instance)\n\
          and comparing bytes/bytearray with str. (-bb: issue errors)\n\
--B     : don't write .pyc files on import; also PYTHONDONTWRITEBYTECODE=x\n\
 -c cmd : program passed in as string (terminates option list)\n\
 -d     : debug output from parser; also PYTHONDEBUG=x\n\
 -E     : ignore PYTHON* environment variables (such as PYTHONPATH)\n\
@@ -817,9 +816,9 @@ pymain_parse_cmdline_impl(_PyMain *pymain, _PyCoreConfig *config,
             cmdline->optimization_level++;
             break;
 
-        case 'B':
-            cmdline->dont_write_bytecode++;
-            break;
+        // case 'B':
+        //     cmdline->dont_write_bytecode++;
+        //     break;
 
         case 's':
             cmdline->no_user_site_directory++;
@@ -891,6 +890,8 @@ pymain_parse_cmdline_impl(_PyMain *pymain, _PyCoreConfig *config,
             return 1;
         }
     } while (1);
+    
+    cmdline->dont_write_bytecode++;
 
     if (pymain->command == NULL && pymain->module == NULL
         && _PyOS_optind < pymain->argc
diff --git a/Objects/codeobject.c b/Objects/codeobject.c
index 7ef0125..23ea5d4 100644
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -277,7 +277,7 @@ static PyMemberDef code_memberlist[] = {
     {"co_nlocals",      T_INT,          OFF(co_nlocals),        READONLY},
     {"co_stacksize",T_INT,              OFF(co_stacksize),      READONLY},
     {"co_flags",        T_INT,          OFF(co_flags),          READONLY},
-    {"co_code",         T_OBJECT,       OFF(co_code),           READONLY},
+    // {"co_code",         T_OBJECT,       OFF(co_code),           READONLY},
     {"co_consts",       T_OBJECT,       OFF(co_consts),         READONLY},
     {"co_names",        T_OBJECT,       OFF(co_names),          READONLY},
     {"co_varnames",     T_OBJECT,       OFF(co_varnames),       READONLY},
diff --git a/Python/decrypt_source_file.c b/Python/decrypt_source_file.c
new file mode 100644
index 0000000..51917d3
--- /dev/null
+++ b/Python/decrypt_source_file.c
@@ -0,0 +1,126 @@
+#include "decrypt_source_file.h"
+
+static unsigned char* str2hex (char *str);
+static void encrypt_buf (char *raw_buf, char **encrpy_buf, int len);
+static void decrypt_buf (char *raw_buf, char **encrpy_buf, int len);
+static int decrypt_open (char *filename);
+
+
+/**
+ * @description 用于替换源码中的fopen(file, "r"); 
+ */
+FILE* d_open(char *filename, const char *modes)
+{
+    if (strcmp(modes, "r") != 0) {
+        return fopen(filename, modes);
+    }
+    FILE *ret = NULL;
+    int fd;
+    fd = decrypt_open(filename);
+    if ( fd < 0 ){
+       // perror("error");
+        return ret;
+    }
+    ret = fdopen(fd, modes);
+
+    return ret;
+}
+
+int dopen(const char *pathname, int flags, mode_t mode)
+{
+#ifdef O_CLOEXEC
+    if (flags != (O_RDONLY | O_CLOEXEC))
+#else
+    if (flags != O_RDONLY)
+#endif
+        return open(pathname, flags, mode);
+    else
+        return decrypt_open(pathname);
+}
+
+/**
+ * @description: 打开加密文件，返回文件描述符
+ * @param filename 表示需要解密的文件
+ * @return 返回解密后的文件的文件描述符，失败返回-1
+ */
+static int decrypt_open (char *filename)
+{
+    int ret = -1;
+    int original_file_fd = open (filename, O_RDONLY);
+    int size = 0;
+    char buf[64] = {0};
+    char filehead[512] = {0};
+    char *de_buf = (char *)malloc (64);
+
+    char template[] = "decrypt-file-XXXXXX"; 
+    ret = mkstemp (template);
+    if (ret == -1){
+        close(original_file_fd);
+        return -1;
+    }
+        
+    // 是否输出解密后的文件
+#ifdef _NO_DECRYPT_FILE_OUTPUT
+    unlink (template); 
+#endif
+    
+    // 读取文件头
+    size = read (original_file_fd, filehead, sizeof(HEADINFO)-1);
+    if ( size < 0 ){
+        close (original_file_fd);
+        close (ret);
+        return -1;
+    }
+    filehead[size] = 0;
+    // 普通文件直接打开
+    if(strcmp(filehead, HEADINFO) != 0) {
+        close (ret);
+        ret = original_file_fd;
+        lseek (ret, 0, SEEK_SET);
+        return ret;
+    }
+
+    // 加密文件解密后打开
+    while ((size = read (original_file_fd, buf, 64)) > 0) {
+        int end_pos = 0;
+        decrypt_buf (buf, &de_buf, 64);
+        for (int i = 63; i >= 0; i--) {
+            if (de_buf[i] != 0) {
+                end_pos = i + 1;
+                break;
+            }
+        }
+        if (write (ret, de_buf, end_pos) == -1) {
+            close(original_file_fd);
+            close(ret);
+            return -1;
+        }
+        memset (buf,0,64);
+    }
+    lseek (ret,0,SEEK_SET);
+    free (de_buf);
+    close(original_file_fd);
+    return ret;
+}
+
+static unsigned char* str2hex (char *str) {
+    unsigned char *ret = NULL;
+    int str_len = strlen (str);
+    int i = 0;
+    assert ((str_len%2) == 0);
+    ret = (char *) malloc (str_len/2);
+    for (i =0;i < str_len; i = i + 2 ) {
+        sscanf (str + i, "%2hhx", &ret[i / 2]);
+    }
+    return ret;
+}
+
+static void decrypt_buf (char *raw_buf, char **encrpy_buf, int len ) {
+    AES_KEY aes;
+    unsigned char *key = str2hex (KEY);
+    unsigned char *iv  = str2hex (IV);
+    AES_set_decrypt_key (key,128,&aes);
+    AES_cbc_encrypt (raw_buf, *encrpy_buf, len, &aes, iv, AES_DECRYPT);
+    free (key);
+    free (iv);
+}
diff --git a/Python/fileutils.c b/Python/fileutils.c
index 5e71d37..05b66fc 100644
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -1,6 +1,7 @@
 #include "Python.h"
 #include "osdefs.h"
 #include <locale.h>
+#include "decrypt_source_file.h"
 
 #ifdef MS_WINDOWS
 #  include <malloc.h>
@@ -1252,7 +1253,7 @@ _Py_wfopen(const wchar_t *path, const wchar_t *mode)
     if (cpath == NULL) {
         return NULL;
     }
-    f = fopen(cpath, cmode);
+    f = d_open(cpath, cmode);
     PyMem_RawFree(cpath);
 #else
     f = _wfopen(path, mode);
