diff --git a/Include/decrypt_source_file.h b/Include/decrypt_source_file.h
new file mode 100644
index 0000000..71de9e0
--- /dev/null
+++ b/Include/decrypt_source_file.h
@@ -0,0 +1,30 @@
+#ifndef _DECRYPY_SOURCE_FILE
+#define _DECRIPT_SOURCE_FILE
+#include <Python.h>
+#include <math.h>
+
+#include <openssl/aes.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+/**
+ * @description: decrypt_file.c使用对称加密算法AES加密文件，密钥长度为128bit 
+ * @dependencies: openssl
+ */
+
+#define KEY  "8cc72b05705d5c46f412af8cbed55aad"
+#define IV   "667b02a85c61c786def4521b060265e8"
+#define HEADINFO "webray-encrypted-python-source-file"
+#define _NO_DECRYPT_FILE_OUTPUT // 是否需要输出解密后的文件
+
+// 可以使用的函数
+int test(void);
+FILE * d_open();
+
+#endif
\ No newline at end of file
diff --git a/Makefile.pre.in b/Makefile.pre.in
index 9297e7f..4e11afe 100644
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -185,7 +185,7 @@ INSTSONAME=	@INSTSONAME@
 LIBS=		@LIBS@
 LIBM=		@LIBM@
 LIBC=		@LIBC@
-SYSLIBS=	$(LIBM) $(LIBC)
+SYSLIBS=	$(LIBM) $(LIBC)  -lcrypto -lssl
 SHLIBS=		@SHLIBS@
 
 THREADOBJ=	@THREADOBJ@
@@ -294,6 +294,7 @@ PGENOBJS=	$(POBJS) $(PGOBJS)
 
 ##########################################################################
 PYTHON_OBJS=	\
+		Python/decrypt_source_file.o \
 		Python/_warnings.o \
 		Python/Python-ast.o \
 		Python/asdl.o \
@@ -752,6 +753,7 @@ Python/formatter_string.o: $(srcdir)/Python/formatter_string.c \
 # Header files
 
 PYTHON_HEADERS= \
+		Include/decrypt_source_file.h \
 		Include/Python-ast.h \
 		Include/Python.h \
 		Include/abstract.h \
diff --git a/Modules/main.c b/Modules/main.c
index a6edf82..a3e9bbb 100644
--- a/Modules/main.c
+++ b/Modules/main.c
@@ -4,6 +4,7 @@
 #include "osdefs.h"
 #include "code.h" /* For CO_FUTURE_DIVISION */
 #include "import.h"
+#include "decrypt_source_file.h"
 
 #ifdef __VMS
 #include <unixlib.h>
@@ -64,7 +65,6 @@ static char *usage_1 = "\
 Options and arguments (and corresponding environment variables):\n\
 -b     : issue warnings about comparing bytearray with unicode\n\
          (-bb: issue errors)\n\
--B     : don't write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x\n\
 -c cmd : program passed in as string (terminates option list)\n\
 -d     : debug output from parser; also PYTHONDEBUG=x\n\
 -E     : ignore PYTHON* environment variables (such as PYTHONPATH)\n\
@@ -375,9 +375,9 @@ Py_Main(int argc, char **argv)
             Py_OptimizeFlag++;
             break;
 
-        case 'B':
-            Py_DontWriteBytecodeFlag++;
-            break;
+        // case 'B':
+        //     Py_DontWriteBytecodeFlag++;
+        //     break;
 
         case 's':
             Py_NoUserSiteDirectory++;
@@ -443,7 +443,7 @@ Py_Main(int argc, char **argv)
 
         }
     }
-
+    Py_DontWriteBytecodeFlag++;
     if (help)
         return usage(0, argv[0]);
 
@@ -607,7 +607,7 @@ Py_Main(int argc, char **argv)
         }
 
         if (sts==-1 && filename!=NULL) {
-            if ((fp = fopen(filename, "r")) == NULL) {
+            if ((fp = d_open(filename, "r")) == NULL) {
                 fprintf(stderr, "%s: can't open file '%s': [Errno %d] %s\n",
                     argv[0], filename, errno, strerror(errno));
 
diff --git a/Objects/codeobject.c b/Objects/codeobject.c
index a66aa69..33bc4eb 100644
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -202,7 +202,7 @@ static PyMemberDef code_memberlist[] = {
     {"co_nlocals",      T_INT,          OFF(co_nlocals),        READONLY},
     {"co_stacksize",T_INT,              OFF(co_stacksize),      READONLY},
     {"co_flags",        T_INT,          OFF(co_flags),          READONLY},
-    {"co_code",         T_OBJECT,       OFF(co_code),           READONLY},
+    // {"co_code",         T_OBJECT,       OFF(co_code),           READONLY},
     {"co_consts",       T_OBJECT,       OFF(co_consts),         READONLY},
     {"co_names",        T_OBJECT,       OFF(co_names),          READONLY},
     {"co_varnames",     T_OBJECT,       OFF(co_varnames),       READONLY},
diff --git a/Python/decrypt_source_file.c b/Python/decrypt_source_file.c
new file mode 100644
index 0000000..aeee608
--- /dev/null
+++ b/Python/decrypt_source_file.c
@@ -0,0 +1,112 @@
+#include "decrypt_source_file.h"
+
+static unsigned char* str2hex (char *str);
+static void encrypt_buf (char *raw_buf, char **encrpy_buf, int len);
+static void decrypt_buf (char *raw_buf, char **encrpy_buf, int len);
+static int decrypt_open (char *filename);
+
+
+/**
+ * @description 用于替换源码中的fopen(file, "r"); 
+ */
+FILE* d_open(char *filename, const char *modes)
+{
+    FILE *ret = NULL;
+    int fd;
+    fd = decrypt_open(filename);
+    if ( fd < 0 ){
+       // perror("error");
+        return ret;
+    }
+    ret = fdopen(fd, modes);
+
+    return ret;
+}
+
+
+/**
+ * @description: 打开加密文件，返回文件描述符
+ * @param filename 表示需要解密的文件
+ * @return 返回解密后的文件的文件描述符，失败返回-1
+ */
+static int decrypt_open (char *filename)
+{
+    int ret = -1;
+    int original_file_fd = open (filename, O_RDWR);
+    int size = 0;
+    char buf[64] = {0};
+    char filehead[512] = {0};
+    char *de_buf = (char *)malloc (64);
+
+    char template[] = "decrypt-file-XXXXXX"; 
+    ret = mkstemp (template);
+    if (ret == -1){
+        close(original_file_fd);
+        return -1;
+    }
+        
+    // 是否输出解密后的文件
+#ifdef _NO_DECRYPT_FILE_OUTPUT
+    unlink (template); 
+#endif
+    
+    // 读取文件头
+    size = read (original_file_fd, filehead, sizeof(HEADINFO)-1);
+    if ( size < 0 ){
+        close (original_file_fd);
+        close (ret);
+        return -1;
+    }
+    filehead[size] = 0;
+    // 普通文件直接打开
+    if(strcmp(filehead, HEADINFO) != 0) {
+        close (ret);
+        ret = original_file_fd;
+        lseek (ret, 0, SEEK_SET);
+        return ret;
+    }
+
+    // 加密文件解密后打开
+    while ((size = read (original_file_fd, buf, 64)) > 0) {
+        int end_pos = 0;
+        decrypt_buf (buf, &de_buf, 64);
+        for (int i = 63; i >= 0; i--) {
+            if (de_buf[i] != 0) {
+                end_pos = i + 1;
+                break;
+            }
+        }
+        if (write (ret, de_buf, end_pos) == -1) {
+            close(original_file_fd);
+            close(ret);
+            return -1;
+        }
+        memset (buf,0,64);
+    }
+    lseek (ret,0,SEEK_SET);
+    free (de_buf);
+    close(original_file_fd);
+    return ret;
+}
+
+static unsigned char* str2hex (char *str) {
+    unsigned char *ret = NULL;
+    int str_len = strlen (str);
+    int i = 0;
+    assert ((str_len%2) == 0);
+    ret = (char *) malloc (str_len/2);
+    for (i =0;i < str_len; i = i + 2 ) {
+        sscanf (str + i, "%2hhx", &ret[i / 2]);
+    }
+    return ret;
+}
+
+static void decrypt_buf (char *raw_buf, char **encrpy_buf, int len ) {
+    AES_KEY aes;
+    unsigned char *key = str2hex (KEY);
+    unsigned char *iv  = str2hex (IV);
+    AES_set_decrypt_key (key,128,&aes);
+    AES_cbc_encrypt (raw_buf, *encrpy_buf, len, &aes, iv, AES_DECRYPT);
+    free (key);
+    free (iv);
+}
diff --git a/Python/import.c b/Python/import.c
index 1d74faf..a996722 100644
--- a/Python/import.c
+++ b/Python/import.c
@@ -14,6 +14,7 @@
 #include "eval.h"
 #include "osdefs.h"
 #include "importdl.h"
+#include "decrypt_source_file.h"
 
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
@@ -1575,7 +1576,7 @@ find_module(char *fullname, char *subname, PyObject *path, char *buf,
             filemode = fdp->mode;
             if (filemode[0] == 'U')
                 filemode = "r" PY_STDIOTEXTMODE;
-            fp = fopen(buf, filemode);
+            fp = d_open(buf, filemode);
             if (fp != NULL) {
                 if (case_ok(buf, len, namelen, name))
                     break;
diff --git a/Python/pythonrun.c b/Python/pythonrun.c
index 44fe13d..c7a62ba 100644
--- a/Python/pythonrun.c
+++ b/Python/pythonrun.c
@@ -191,8 +191,8 @@ Py_InitializeEx(int install_sigs)
         Py_VerboseFlag = add_flag(Py_VerboseFlag, p);
     if ((p = Py_GETENV("PYTHONOPTIMIZE")) && *p != '\0')
         Py_OptimizeFlag = add_flag(Py_OptimizeFlag, p);
-    if ((p = Py_GETENV("PYTHONDONTWRITEBYTECODE")) && *p != '\0')
-        Py_DontWriteBytecodeFlag = add_flag(Py_DontWriteBytecodeFlag, p);
+    // if ((p = Py_GETENV("PYTHONDONTWRITEBYTECODE")) && *p != '\0')
+    //     Py_DontWriteBytecodeFlag = add_flag(Py_DontWriteBytecodeFlag, p);
     /* The variable is only tested for existence here; _PyRandom_Init will
        check its value further. */
     if ((p = Py_GETENV("PYTHONHASHSEED")) && *p != '\0')
